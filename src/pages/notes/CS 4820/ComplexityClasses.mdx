---
layout: ../../../layouts/Note.astro
title: "Complexity Classes"
---

import { M } from "../../../components/Math";

# Notes on complexity classes

Complexity classes are a classification of computational problems based on the time complexity of their solutions. Some problems, like stable matching, are solvable in a polynomial time complexity <M>O(n^a)</M>, where <M>a\in\mathbb\{R}</M>.

These are problems are under the **P (polynomial)** class

**Decision problems** are problems where given some solution <M>n</M> for some problem <M>s</M>, we output YES if <M>n</M> is valid and NO otherwise

**NP (non-deterministic polynomial time)** problems are a special group of decision problems where we can check if a solution <M>s</M> is valid in polynomial time.

**NP Complete** problems are NP problems that we currently have no solution for in polynomial time. They are unique because finding the algorithm to solve one efficiently means that an efficient algorithm exists to solve every other NP-complete problem. This is provable through reduction, which we'll cover in a second.

An important skill for this topic is being able to prove that one problem is a **reduction** of another. A reduction is a formal relationship claiming that one problem is of equal difficulty as another problem.

Here's an example of a reduction of two problems <M>A</M> and <M>B</M>: let's say <M>A \leq_R B</M>. This tells us that problem <M>B</M> is at least as hard to solve as <M>A</M> (in terms of time complexity).

We focus on **polynomial-time reducibility**, which essentially says that if we have a black box algorithm that can solve problem <M>B</M>, then problem <M>A</M> can also be solved with a polynomial number of steps in addition to using that black box algorithm a polynomial number of times.

If the black box algorithm itself is <M>O(n^a)</M>, then under polynomial-time reduction <M>A</M> is also solvable in polynomial time.

## Tractability

We can compare **tractability**, or the complexity of different problems, by mapping the input and steps needed for one problem into a second problem. Following is an example of this technique for the Independent Set Problem and the Vertex Cover Problem.

---

let S be V - A, where A is an independent set. Prove that S is a vertex cover.

- arbitrary edge e = (u, v)
- contradictory that both u, v in A, because then A would not be independent.
- for any edge e, at most one endpoint can be in A
- S is a vertex cover

let A be V - S, where S is a vertex cover. Prove that A is an independent set.

- arbitrary edge e = (u, v)
- contradiction: suppose u, v both in A. This violates condition of each edge having at least one endpoint in S.
- for any edge e, at least one endpoint has to be in S
- synonymously, at most one endpoint for arbitrary edge e can be in A
- A is an independent set

Reductions follow naturally:

Prove that Independent Set \\(\leq_R\\) Vertex Cover

- let B be some black box algorithm that can solve vertex cover decision prob.
- given any graph G, iterate through possible values of k, determining smallest possible k for vertex cover
- inverse is the independent set; \\(||G|| - k\\) guaranteed to be largest size

Prove that Vertex Cover \\(\leq_R\\) Independent Set

- let B be some black box algorithm that can solve independent set
- find largest possible indep. set (polynomial)
- inverse is vertex cover.

<figure>
  Set Cover (decision version) - general prob where given set \\(U\\), integer
  \\(k\\), and list of subsets \\(S\\), is it possible to get \\(U\\) through a
  union of \\(k\\) elements from \\(S\\)
</figure>

Prove that Vertex Cover \\(\leq_R\\) Set Cover

- suppose we have black box that can solve decision version of set cover
- create a set cover instance where ground set (\\(U\\)) is equal to the all vertices. each subset \\(S_i\\) corresponds with all the edges that would be covered if \\(v_i\\) were included
- picking subset \\(S_i\\) equal to picking \\(v_i\\)
- summary: to solve for \\(k\\) vertex cover, prob on \\(G=(E, V)\\), create subsets \\(S_i \dots\\) for each \\(v\\) that corresponds with all vertices that would be covered if \\(v\\) were added/selected. use black box to solve this instance, return answer for black box.

note: for reductions, we almost always find a mapping from one problem to another and call the black box once.

---

\\(A\\) is algo that solves decision prob
\\(X\\) is set containing YES's to the problem
\\(A\\) solves \\(X\\) only if for all binary strings \\(s\\), \\(A(s) = \\) yes and \\(s\in X\\)

\\(A\\) has polynomial running time if exists a polynomial function \\(p(\cdot)\\) such that \\(A\\) is of \\(O(p(\|s\|))\\) complexity. In other words, the time complexity of \\(A\\) must be a polynomial function of its input size

---

# Certifying NP

a certifier \\(B\\) is an algorithm that can verify if a solution is correct for a problem

Some certifier \\(B\\) is a function that takes two parameters \\(s\\) and \\(t\\), with \\(s\\)
representing an input and \\(t\\) a verification ('correct answer') used to check
if \\(s\\) is valid

Efficient certification involves

- existence of polytime certifier \\(B\\) that takes inputs \\(s, t\\)
- existence of some polynomial function \\(p\\) such that \\(s\in X\\) only if \\(\|t\| \leq p(\|s\|)\\) and \\(B(s, t)\\) is YES

In other words, an efficient certification is valid only when

- there is a certifier that can correctly check if a solution works in polynomial time
- all \\(s\\) have a certifier string \\(t\\) that has a polynomial relationship to it

<figure>
  **NP** is any problem with an efficient (polynomial time) certifier; it is
  possible to check in polynomial time that an answer to the problem is correct
</figure>

examples

- 3Sat: \\(t\\) assignment of truth values to variables
- Set Cover: \\(t\\) is a list of \\(k\\) sets, \\(B\\) checks if union equals list
- Independent Set: \\(t\\) is identity of a set with at least \\(k\\) vertices. \\(B\\) checks that no edges exist inbetween them

## Showing something is NP complete

Since we don't know the answer to \\(\mathcal\{P = NP\}\\), we have instead turned focus to determine how problems in \\(\mathcal\{NP\}\\) relate to one another.

To show that a problem is NP-complete, we must reduce it to some existing np problem:

<figure>
  <figcaption>Proving NP completeness for some problem \\(B\\)</figcaption>
  <p>
    Show that problem can be efficiently verified in polynomial time with a
    certifier.
  </p>
  <p>
    Then, \\(A\\) show \\(A \leq_R B \\). In other words, show that every
    instance of \\(B\\) can be reduced to an example of \\(A\\)
  </p>
</figure>

## Circuit Satisfiability

physical analogue to boolean satisfiability

must show for some algo \\(X\\) that \\(X\leq_R\\) Circuit Satisfiability.

know that \\(B(\cdot, \cdot)\\) is efficient certifier

{/* question: why specific? why do we not have to worry about arbitrary s? */}

must answer: for specific input \\(s\\), does there exist \\(t\\) of length \\(p(l)\\) such that \\(B(s, t) = \\) YES?

can be reduced to SAT

3SAT also reducable to SAT
